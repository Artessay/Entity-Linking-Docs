# 探索在生物医学概念链接方面大语言模型的情景学习能力

EXPLORING THE IN-CONTEXT LEARNING ABILITY OF LARGE LANGUAGE MODEL FOR BIOMEDICAL CONCEPT LINKING

## 摘要

本文探索了大语言模型的情景学习能力在生物医学概率链接上的应用。

两阶段框架：
* retrieve（提取）
  * 采用语言模型将生物医学概念进行嵌入
* rank（排名） 
  * 利用嵌入的相似度排名提取靠前的候选者
  * 候选者的上下文信息被纳入提示词（prompt），通过大语言模型进行处理，并重新对这些概念排序

BC5CDR数据集的精确率
* 疾病实体规范化：90.1% disease
* 化学实体规范化：94.7% chemical

## 简介

在生物医学领域，名词更新迭代速度快，概念数量众多，采用人工标注的方式进行训练是不可行的。

模型目标：
* 不需要针对特定任务的训练数据
* 能够处理复杂且模糊的生物医学概念



![Alt text](_img/biomedical-fig1.png)



## 背景介绍

### 生物医学

生物医学领域在许多方面都十分依赖概念链接（concept linking），比如：文献挖掘（literature mining）、图对齐（graph alignment）、信息抽取（information retrieval）、问答、知识集成（knowledge integration）等。

虽然大语言模型已经在自然语言处理的许多领域有了很好的表现，但是在生物医学概念匹配上还没有被很好地探索。

### 疾病词标准化

疾病词的标准化（Disease Name Normalization）是一个非常复杂的任务，疾病词通常是由希腊和拉丁的词根和词缀构造的，比如hemochromatosis（血色素沉着病）。另一种灵活的疾病词创建方式是疾病分类（disease category）加上短修饰词（modifier），其中包括

解剖部位（anatomical locations ）。比如breast cancer，乳癌
症状（symptoms ）。比如cat-eye syndrome，猫眼综合征
治疗方案（treatment ）。比如Dopa-responsive dystonia，多巴反应性肌张力失常
病原体（causative agent）。比如staph infection，葡萄球菌感染
生物分子病因（biomolecular etiology ），比如G6PD deficiency，葡萄糖-6-磷酸脱氢酶不足
基因特征（heredity ），比如X-linked agammaglobulinemia，X连锁无丙种球蛋白血症
人名命名（eponyms），比如Schwartz-Jampel syndrome，Schwartz-Jampel综合征
程度描述，比如severe malaria， 严重疟疾
当疾病词在文本中出现的时候，有很多简写，形态变换，词顺序变化和同义词。这些都给疾病标准化带来了困难。另外有可能一个词代表多个意思，比如oculocerebrorenal（眼脑肾的），包含眼、脑、肾三个解剖部位，所以有可能一个修饰词会跟多个标准概念对应。

传统方法多是基于字符串匹配的方法，泛化能力不强。在文章《DNorm: disease name normalization with pairwise learning to rank》中首次提出了一种机器学习的方法进行疾病词标准化，这个模型叫做DNorm。这个模型的基本思想是pairwise learning to rank (pLTR)，也就是比较文本中发现的mention和知识库中的实体概念相似性并进行打分排序。

### 二分图匹配

#### 二分图

二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。简而言之，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。

![Alt text](_img/bipartite-graph.png)

#### 二分图匹配

给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。求二分图匹配可以用最大流(Maximal Flow)或者匈牙利算法(Hungarian Algorithm)。

#### 二分图判断

对于二分图的问题我们首先要判断一个图它是不是二分图。对于二分图的判断方法最常见的是染色法，顾名思义就是我们对每一个点进行染色操作，我们只用黑白两种颜色，问能不能使所有的点都染上了色，而且相邻两个点的颜色不同，如果可以那么这个图就是一个二分图，对于判断是否是一个二分图的方法可以用dfs和bfs两种方式去实现。下面我就上一个bfs的判断二分图的代码。

```c++
vector<int> G[maxn];  // 存边
int col[maxn];        // 标记顶点颜色
int n,m;         // 点和边的个数
bool bfs(){
  queue<int> q;
  q.push(1);     // 放入第一个点
  memset(col,0,sizeof(col));
  col[1] = 1;    // 先标记第一个点为1
  while(!q.empty()){
    int v = q.front();
    q.pop();
    for(int i=0;i<G[v].size();i++){
      int xx = G[v][i];
      if(col[xx] == 0){      // 判断这个点是否标记过
        col[xx] = -col[v];   // 没有标记过就标记上与v相反的颜色
        q.push(xx);
      }
      else{
        if(col[v] == col[xx]){    // 如果颜色冲突说明不是二分图
          return false;
        }
      }
    }
  }
  return true;
}
```

#### 二分图最大匹配

给定一个二分图 G，即分左右两部分，各部分之间的点没有边连接，要求选出一些边，使得这些边没有公共顶点，且边的数量最大。

##### 增广路算法 Augmenting Path Algorithm

因为增广路长度为奇数，路径起始点非左即右，所以我们先考虑从左边的未匹配点找增广路。 注意到因为交错路的关系，增广路上的第奇数条边都是非匹配边，第偶数条边都是匹配边，于是左到右都是非匹配边，右到左都是匹配边。 于是我们给二分图 定向，问题转换成，有向图中从给定起点找一条简单路径走到某个未匹配点，此问题等价给定起始点 s 能否走到终点 t。 那么只要从起始点开始 DFS 遍历直到找到某个未匹配点，O(m)。 未找到增广路时，我们拓展的路也称为 交错树。

```c++
struct augment_path {
  vector<vector<int> > g;
  vector<int> pa;  // 匹配
  vector<int> pb;
  vector<int> vis;  // 访问
  int n, m;         // 两个点集中的顶点数量
  int dfn;          // 时间戳记
  int res;          // 匹配数

  augment_path(int _n, int _m) : n(_n), m(_m) {
    assert(0 <= n && 0 <= m);
    pa = vector<int>(n, -1);
    pb = vector<int>(m, -1);
    vis = vector<int>(n);
    g.resize(n);
    res = 0;
    dfn = 0;
  }

  void add(int from, int to) {
    assert(0 <= from && from < n && 0 <= to && to < m);
    g[from].push_back(to);
  }

  bool dfs(int v) {
    vis[v] = dfn;
    for (int u : g[v]) {
      if (pb[u] == -1) {
        pb[u] = v;
        pa[v] = u;
        return true;
      }
    }
    for (int u : g[v]) {
      if (vis[pb[u]] != dfn && dfs(pb[u])) {
        pa[v] = u;
        pb[u] = v;
        return true;
      }
    }
    return false;
  }

  int solve() {
    while (true) {
      dfn++;
      int cnt = 0;
      for (int i = 0; i < n; i++) {
        if (pa[i] == -1 && dfs(i)) {
          cnt++;
        }
      }
      if (cnt == 0) {
        break;
      }
      res += cnt;
    }
    return res;
  }
};
```

##### 网络最大流模型

二分图最大匹配可以转换成网络流模型。

将源点连上左边所有点，右边所有点连上汇点，容量皆为 1。原来的每条边从左往右连边，容量也皆为 1，最大流即最大匹配。

如果使用 Dinic 算法 求该网络的最大流，可在 $O(\sqrt{n}m)$ 求出。

Dinic 算法分成两部分，第一部分用 O(m) 时间 BFS 建立网络流，第二步是 O(nm) 时间 DFS 进行增广。

但因为容量为 1，所以实际时间复杂度为 O(m)。

接下来前 $O(\sqrt{n})$ 轮，复杂度为 $O(\sqrt{n}m)$。$O(\sqrt{n})$ 轮以后，每条增广路径长度至少 $\sqrt{n}$，而这样的路径不超过 $\sqrt{n}$，所以此时最多只需要跑 $\sqrt{n}$ 轮，整体复杂度为 $O(\sqrt{n}m)$。

代码可以参考 Dinic 算法 的参考实现，这里不再给出。

### 生物医学名词解释

oncology：肿瘤学 

